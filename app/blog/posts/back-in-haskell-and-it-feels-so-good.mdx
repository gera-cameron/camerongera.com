---
title: 'Back in Haskell—and It Feels So Good'
publishedAt: '2025-02-12'
summary: 'Returning to Haskell professionally after years away, and how functional thinking (plus a jump into PureScript) made the transition seamless.'
---

After a few years away, I’m back to writing Haskell professionally—and wow, it feels like coming home.

## Functional Thinking Never Left

During my time away from Haskell, I worked in a variety of languages and stacks: TypeScript, Node, React, even a little Python and Go. But no matter what language I was using, I found myself reaching for functional programming concepts. Pure functions, immutability, composition, and higher-order abstractions became my default way of thinking about problems.

This mindset made the transition back to Haskell almost effortless. Sure, I had to dust off some syntax and reacquaint myself with the type system’s quirks, but the core ideas—modeling with algebraic data types, leveraging typeclasses, and composing small, pure functions—were second nature.

## Why Haskell Still Feels Special

There’s something uniquely satisfying about Haskell’s type system and expressiveness. Pattern matching, type inference, and the ability to encode invariants at the type level make for a delightful developer experience. I’d missed the confidence that comes from knowing the compiler has your back.

A few things that stood out immediately upon my return:

- **Type-Driven Development**: Letting the types guide the design, and using the compiler as a design partner.
- **Expressive Abstractions**: Monads, functors, and applicatives aren’t just academic—they’re practical tools for structuring real-world code.
- **Refactoring Joy**: Refactoring in Haskell is a pleasure. If it compiles, it (almost always) works.

## Jumping into PureScript

As a bonus, I’ve also started working with [PureScript](https://www.purescript.org/), Haskell’s close cousin for the front-end. If you love Haskell, PureScript feels like a natural extension—many of the same abstractions, but targeting JavaScript and the browser.

### Haskell vs. PureScript: A Quick Comparison

| Feature                | Haskell                        | PureScript                    |
|------------------------|-------------------------------|-------------------------------|
| Type System            | Hindley-Milner, very strong   | Hindley-Milner, very strong   |
| Ecosystem              | Mature, lots of libraries     | Smaller, but growing          |
| Target                 | Native (via GHC)              | JavaScript (via JS backend)   |
| Syntax                 | Very similar                  | Very similar                  |
| Tooling                | Stack, Cabal, GHCi            | Spago, PSCi                   |
| Interop                | C (via FFI)                   | JavaScript (via FFI)          |

The biggest difference is in the ecosystem and the target platform. PureScript’s interop with JavaScript is fantastic, and it’s a joy to bring type safety and functional purity to the front-end.

## Functional Habits Pay Off

If you’ve been thinking functionally—even in “non-functional” languages—the jump back into Haskell (or into PureScript) is smooth. Concepts like immutability, function composition, and declarative data modeling transcend language boundaries. Haskell just gives you the best tools to express them.

## Final Thoughts

I’m grateful to be back in the Haskell world, and excited to explore more with PureScript. If you’re a functional programming enthusiast, don’t be afraid to bring those habits with you wherever you go—they’ll serve you well, and make every return to Haskell feel like a homecoming.

Happy hacking!

(Assisted by AI)
